# setupimport randomimport osfrom Simulation import Simulationfrom util import printProgressBarimport numpy as npimport timefrom SimulationManager import SimulationManager, SimulationGroup#TODO:# Trajektorien von einzelnen Teilchen bei unterschiedlichen Parametern der Schwingung überprüfen# Simulationsbox in Gitter mit Abstand des Interaktionsradius aufteilen, um Interaktionsberechnung effizienter zu machenif __name__ == "__main__":    starttime = time.perf_counter()    # simulationDir = '/local/kzisiadis/vicsek-simulation'    # simulationDir = 'E:/simulationdata/mptest'    # simulationDir = 'D:\\simulationdata'    # simulationManager = SimulationManager(simulationDir)    #    #    # def initialSwimmerParametersameRhoConstants(simulationIndex, totalNumberOfSimulations, swimmerIndex):    #     return {    #         "oscillationAmplitude": 0,    #         "oscillationPeriod": 1,  # how many timesteps for one full oscillation    #         "oscillationPhaseshift": 0    #     }    # def sameRhoConstants400(simulationIndex, numSimulation):    #     return {    #         "timeSteps": 72,    #    #         "environmentSideLength": 10,    #         "numSwimmers": 400,    #         "interactionRadius": 1,    #         "randomAngleAmplitude": 15 * (simulationIndex / numSimulation),    #    #         "initialVelocity": 0.0025,    #         "swimmerSize": 0.04,    #    #         "saveVideo": False,    #     }    #    #    # sameRhoGroup400 = SimulationGroup(simulationDataDir=os.path.join(simulationDir, 'sameRhoGroup400'),    #                                   constantsFunc=sameRhoConstants400,    #                                   initialParameterFunc=initialSwimmerParametersameRhoConstants,    #                                   numSimulation=35, repeatNum=15,    #                                   timePercentageUsedForMean=25,    #                                   saveTrajectoryData=False)    # simulationManager.appendGroup(sameRhoGroup400)    #    # simulationManager.simulate()    def initialSwimmerParameter(simulationIndex, totalNumberOfSimulations, swimmerIndex):        return {            "oscillationAmplitude": np.pi / 16,            "oscillationPeriod": 40,  # how many timesteps for one full oscillation            "oscillationPhaseshift": 0        }    constants = {        "timeSteps": 7200,        "environmentSideLength": 10,        "numSwimmers": 400,        "interactionRadius": 1,        "randomAngleAmplitude": 2,        "initialVelocity": 0.0025,        "swimmerSize": 0.04,        "saveVideo": True,    }    simulation = Simulation(simulationIndex=1, numSimulation=1, constants=constants, initialParameterFunc=initialSwimmerParameter, timePercentageUsedForMean=25)    simulation.simulate()    print(simulation.getAbsoluteVelocityTotal())    print('That took {} seconds'.format(time.perf_counter() - starttime))    simulation.animate()